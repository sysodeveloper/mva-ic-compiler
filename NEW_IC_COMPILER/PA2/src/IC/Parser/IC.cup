                                                 
                                                                  
                                                                    
                                            
package IC.Parser;

import IC.*;
import IC.AST.*;
import IC.DataTypes;
import java_cup.runtime.*;
import java.util.*;

parser code  {:
    /** Causes the parser to print every token it reads.
     * This is useful for debugging.
     */
    public boolean printTokens;
    
    private Lexer lexer;

    public Parser(Lexer lexer) {
        super(lexer);
        this.lexer = lexer;
    }
    
    public int getLine() {
        return lexer.getLineNumber();
    }
    
    public void syntax_error(Symbol s) {
        Token tok = (Token) s;
        System.out.println("Line " + tok.getLineNumber()+": Syntax error; unexpected " + tok);
    }
    
    
:}

// This is just for debugging
scan with {:
    Token t = lexer.next_token();
    if (printTokens)
        System.out.println(t.getLineNumber() + ":" + t);
    return t; 
:};

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

non terminal Program Program;
non terminal ClassIC, ClassICEx, ClassContent,FieldOrMethod,Field,FieldList,VirtualMethod,StaticMethod,MethodType;
non terminal Formals,StatmentOrEmpty,Type,TypeList, Statement,InitVariable,Expr,ExprOrEmpty;
non terminal Call,ElseStatement,StaticCall,VirtualCall,Arguments,ArgumentsList;
non terminal ExprDotOrEmpty, Binop, Unop, Literal, Location;
non terminal MethodPrefix,VirtualCallPrefix;
non terminal StatementStar;
non terminal A,B,C,D,F,G,H,I,J;

terminal         ASSIGN;
terminal INTEGER;
terminal LP, RP , LB , RB , LCBR , RCBR , BOOLEAN , BREAK , COMMA  , EQUAL , EXTENDS , ELSE , FALSE , GT , GTE , ID , IF , INT  , LAND , CLASS , LENGTH , NEW , LNEG , LOR , LT , LTE , MINUS , MOD , MULTIPLY , NEQUAL , NULL , PLUS , RETURN , SEMI , STATIC , STRING , QUOTE , THIS , TRUE , VOID , WHILE , CLASS_ID , PLUSPLUS , MINUSMINUS , PLUSEQUAL , MINUSEQUAL , MULTIPLYEQUAL, CONTINUE, DIVIDE, DIVIDEEQUAL, DOT;
terminal UNOP;

//////////////////////////
// Precedence declarations

precedence right ASSIGN;
precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left GT,GTE,LT,LTE;
precedence left PLUS,MINUS;
precedence left MULTIPLY,DIVIDE,MOD;
precedence left DOT,LB,LP,RB,RP;
precedence right UNOP;
precedence left ELSE;
//////////////
// The grammar



Program ::= ClassIC Program | ClassICEx Program | ;
ClassIC ::= CLASS CLASS_ID ClassContent;
ClassICEx ::= CLASS CLASS_ID EXTENDS CLASS_ID ClassContent;
ClassContent ::= LCBR FieldOrMethod RCBR;
FieldOrMethod ::= Field FieldOrMethod | StaticMethod FieldOrMethod | VirtualMethod FieldOrMethod | ;


Field ::= Type:t ID:i FieldList:flst SEMI 
		{:	 
			ArrayList<Field> lstFields = (ArrayList<Field>)flst;
			ArrayList<Field> TypedFields = new ArrayList<Field>();
			
			for(Field f : lstFields){
				TypedFields.add(new Field((Type)t,f.getName()));				
			}
				
			TypedFields.add( new Field((Type)t, i.toString()) );  
			RESULT = TypedFields;	:};


FieldList ::= COMMA ID:i FieldList:flst
			 {: ArrayList<Field> lstFields = (ArrayList<Field>)flst;
			 	lstFields.add(new Field(new PrimitiveType(parser.getLine(), DataTypes.INT) ,i.toString()) );
			 	RESULT = lstFields; :}|
			 {: RESULT = new ArrayList<Field>();  :} ;
			 

 


Type::= INT 	 	 {: RESULT = new PrimitiveType(parser.getLine(), DataTypes.INT); :} | 
		BOOLEAN		 {: RESULT = new PrimitiveType(parser.getLine(), DataTypes.BOOLEAN); :} | 
		STRING  	 {: RESULT = new PrimitiveType(parser.getLine(), DataTypes.STRING); :} | 
		CLASS_ID:c   {: RESULT = new UserType(parser.getLine(),c.toString()); :} | 
		Type:t LB RB {: ((Type)t).incrementDimension(); RESULT = t; :};


VirtualMethod ::= MethodPrefix Formals RP LCBR StatementStar RCBR ;
MethodPrefix ::= VOID ID LP | Type ID LP;
StaticMethod ::= STATIC MethodPrefix Formals RP LCBR StatementStar RCBR;

Formals::= Type:t ID:i TypeList:lst 
			{:	ArrayList<Formal> lstFormals = (ArrayList<Formal>)lst;
				lstFormals.add(new Formal((Type)t,i.toString()));
				RESULT = lstFormals;:} |
			{:  RESULT = new ArrayList<Formal>(); :}; 


TypeList::=  COMMA Type:t ID:i TypeList:lst 
			{: 	ArrayList<Formal> lstFormals = (ArrayList<Formal>)lst;
				lstFormals.add(new Formal((Type)t,i.toString()));
				RESULT = lstFormals; :} |
			{:  RESULT = new ArrayList<Formal>(); :} ;





Statement ::=   Location ASSIGN Expr SEMI| 
				Call SEMI| 
				RETURN ExprOrEmpty SEMI|
				IF LP Expr RP Statement ELSE Statement|
				IF LP Expr RP Statement|
				WHILE LP Expr RP Statement|	    
			    BREAK SEMI|
			    CONTINUE SEMI|
			    LCBR StatementStar RCBR |   
			    Type ID InitVariable SEMI 
			    ;

StatementStar ::=  Statement StatementStar| ;

InitVariable ::= ASSIGN Expr | ;

ExprOrEmpty ::= Expr| ;

Location ::= ID | Expr DOT ID| Expr LB Expr RB ;

Call ::= StaticCall | VirtualCall;

StaticCall ::= CLASS_ID DOT ID LP Arguments RP;

VirtualCall ::= VirtualCallPrefix Arguments RP | ID LP Arguments RP;

VirtualCallPrefix ::= Expr DOT ID LP;

Arguments ::= Expr ArgumentsList | ;

ArgumentsList ::= COMMA Expr ArgumentsList | ; 

Binop ::= PLUS {: RESULT = BinaryOps.PLUS;  :} |
 		  MINUS  {: RESULT = BinaryOps.MINUS;  :}  |
  		  MULTIPLY  {: RESULT = BinaryOps.MULTIPLY;  :}  |
   		  DIVIDE  {: RESULT = BinaryOps.DIVIDE;  :}  | 
   		  MOD  {: RESULT = BinaryOps.MOD;  :}  |
		  LAND  {: RESULT = BinaryOps.LAND;  :}  |
		  LOR  {: RESULT = BinaryOps.LOR;  :}  |
		  GT  {: RESULT = BinaryOps.GT;  :}  |
       	  GTE  {: RESULT = BinaryOps.GTE;  :}  |
          LT  {: RESULT = BinaryOps.LT;  :}  |
          LTE  {: RESULT = BinaryOps.LTE;  :}  |
          EQUAL  {: RESULT = BinaryOps.EQUAL;  :}  |
          NEQUAL  {: RESULT = BinaryOps.NEQUAL;  :} ;

Unop ::= MINUS {: RESULT = UnaryOps.UMINUS;  :} | 
		 LNEG  {: RESULT = UnaryOps.LNEG;  :};

Literal ::= INTEGER:l
{: RESULT = new Literal(parser.getLine(),LiteralTypes.INTEGER,l); :} | 
QUOTE:l 
{: RESULT = new Literal(parser.getLine(),LiteralTypes.STRING); :} | 
TRUE:l
{: RESULT = new Literal(parser.getLine(),LiteralTypes.TRUE); :} | 
FALSE:l 
{: RESULT = new Literal(parser.getLine(),LiteralTypes.TRUE); :} | 
NULL:l
{: RESULT = new Literal(parser.getLine(),LiteralTypes.NULL); :};

Expr ::= Location|
		Call|
		THIS|
		LP Expr RP|
		NEW CLASS_ID LP RP|
		NEW Type LB Expr RB|
		Expr DOT LENGTH|
		Literal|
		MINUS:uminus Expr:e %prec UNOP|
		LNEG:not Expr:e %prec UNOP |
		Expr Binop Expr;

			
