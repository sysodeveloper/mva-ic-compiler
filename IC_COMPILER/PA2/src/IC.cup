                                                                     
                                                                     
                                                                     
                                             
package IC.Parser;

import IC.AST.*;
import IC.DataTypes;
import java_cup.runtime.*;
import java.util.*;

parser code  {:
    /** Causes the parser to print every token it reads.
     * This is useful for debugging.
     */
    public boolean printTokens;
    
    private Lexer lexer;

    public Parser(Lexer lexer) {
        super(lexer);
        this.lexer = lexer;
    }
    
    public int getLine() {
        return lexer.getLineNumber();
    }
    
    public void syntax_error(Symbol s) {
        Token tok = (Token) s;
        System.out.println("Line " + tok.getLineNumber()+": Syntax error; unexpected " + tok);
    }
    
    
:}

// This is just for debugging
scan with {:
    Token t = lexer.next_token();
    if (printTokens)
        System.out.println(t.getLineNumber() + ":" + t);
    return t; 
:};

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

non terminal Program Program;
non terminal ClassIC, ClassICEx, ClassContent,FieldOrMethod,Field,FieldList,VirtualMethod,StaticMethod,MethodType;
non terminal Formals,StatmentOrEmpty,Type,TypeList, Statement,InitVariable,Expr,ExprOrEmpty;
non terminal Call,ElseStatement,StaticCall,VirtualCall,Arguments,ArgumentsList;
non terminal ExprDotOrEmpty, Binop, Unop, Literal, Location;
non terminal MethodPrefix,VirtualCallPrefix;
non terminal StatementStar;
non terminal A,B,C,D,F,G,H,I,J,BinOpRule,UnOpRule;

terminal         ASSIGN;
terminal Integer INTEGER;
terminal LP, RP , LB , RB , LCBR , RCBR , BOOLEAN , BREAK , COMMA  , EQUAL , EXTENDS , ELSE , FALSE , GT , GTE , ID , IF , INT  , LAND , CLASS , LENGTH , NEW , LNEG , LOR , LT , LTE , MINUS , MOD , MULTIPLY , NEQUAL , NULL , PLUS , RETURN , SEMI , STATIC , STRING , QUOTE , THIS , TRUE , VOID , WHILE , CLASS_ID , PLUSPLUS , MINUSMINUS , PLUSEQUAL , MINUSEQUAL , MULTIPLYEQUAL, CONTINUE, DIVIDE, DIVIDEEQUAL, DOT;
terminal UNOP,POSTUNOP,BINOP;
terminal SecondDot;
terminal FirstDot;

//////////////////////////
// Precedence declarations

precedence left ELSE;
precedence left POSTUNOP;
precedence left BINOP;
precedence right UNOP;
precedence left SecondDot;
precedence left  DOT;
//////////////
// The grammar
Program ::= ClassIC Program | ClassICEx Program | ;
ClassIC ::= CLASS CLASS_ID ClassContent;
ClassICEx ::= CLASS CLASS_ID EXTENDS CLASS_ID ClassContent;
ClassContent ::= LCBR FieldOrMethod RCBR;
FieldOrMethod ::= Field FieldOrMethod | StaticMethod FieldOrMethod | VirtualMethod FieldOrMethod | ;
Field ::= Type ID FieldList SEMI;
FieldList ::= COMMA ID FieldList| ;
Type ::= INT | BOOLEAN | STRING | CLASS_ID | Type LB RB;
VirtualMethod ::= MethodPrefix Formals RP Statement ;
MethodPrefix ::= VOID ID LP | Type ID LP;
StaticMethod ::= STATIC MethodPrefix Formals RP Statement ;
Formals ::= Type ID TypeList | ;
TypeList ::= COMMA Type ID TypeList | ;


Statement ::=   Location ASSIGN Expr SEMI| 
				Call SEMI| 
				RETURN ExprOrEmpty SEMI|
				IF LP Expr RP Statement ELSE Statement %prec ELSE|
				IF LP Expr RP Statement|
				WHILE LP Expr RP Statement|	    
			    BREAK SEMI|
			    CONTINUE SEMI|
			    LCBR StatementStar RCBR |   
			    Type ID InitVariable SEMI 
			    ;

StatementStar ::=  Statement StatementStar| ;


InitVariable ::= ASSIGN Expr | ;

ExprOrEmpty ::= Expr| ;

Location ::= ID | Expr DOT ID %prec DOT | Expr LB Expr RB %prec SecondDot;

Call ::= StaticCall | VirtualCall;

StaticCall ::= CLASS_ID DOT ID LP Arguments RP;

VirtualCall ::= VirtualCallPrefix Arguments RP | ID LP Arguments RP;

VirtualCallPrefix ::= Expr DOT ID LP;

Arguments ::= Expr ArgumentsList | ;

ArgumentsList ::= COMMA Expr ArgumentsList | ; 

Binop ::= PLUS | MINUS | MULTIPLY | DIVIDE | MOD | LAND | LOR | GT | GTE | LT | LTE | EQUAL | NEQUAL;

Unop ::= MINUS | LNEG;

Literal ::= INTEGER | QUOTE | TRUE | FALSE | NULL;

Expr ::= Location|Call|THIS|LP Expr RP|
		NEW CLASS_ID LP RP|
		NEW Type LB Expr RB|
		Expr DOT LENGTH|
		Literal|
		UnOpRule  %prec UNOP |BinOpRule %prec BINOP  ;


UnOpRule ::= MINUS Expr  %prec UNOP| LNEG Expr  %prec UNOP| MINUSMINUS Expr  %prec UNOP|PLUSPLUS Expr  %prec UNOP|
			 Expr MINUSMINUS  %prec POSTUNOP| Expr PLUSPLUS  %prec POSTUNOP;

/*
BinOpRule::=Expr ASSIGN Expr %prec BINOP;

A ::= A LOR B|B;
B ::= B LAND C|C;
C ::= C EQUAL D|C NEQUAL D|D;
D ::= D LT F| D LTE F|D GT F|GTE F|F;
F ::= F PLUS G|F MINUS G|G;
G ::= G MULTIPLY H|G DIVIDE H|G MOD H|H;
H::=Expr;*/
			

